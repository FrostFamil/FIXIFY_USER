{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { CodedError, UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport ExpoAppAuth from \"./ExpoAppAuth\";\n\nfunction isValidServiceConfiguration(config) {\n  return !!(config && typeof config.authorizationEndpoint === 'string' && typeof config.tokenEndpoint === 'string');\n}\n\nfunction assertValidClientId(clientId) {\n  if (typeof clientId !== 'string' || !clientId.length) {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`clientId` must be a string with more than 0 characters');\n  }\n}\n\nfunction assertValidProps(_ref) {\n  var issuer = _ref.issuer,\n      redirectUrl = _ref.redirectUrl,\n      clientId = _ref.clientId,\n      serviceConfiguration = _ref.serviceConfiguration;\n\n  if (typeof issuer !== 'string' && !isValidServiceConfiguration(serviceConfiguration)) {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', 'You must provide either an `issuer` or both `authorizationEndpoint` and `tokenEndpoint`');\n  }\n\n  if (typeof redirectUrl !== 'string') {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`redirectUrl` must be a string');\n  }\n\n  assertValidClientId(clientId);\n}\n\nfunction _executeAsync(props) {\n  return _regeneratorRuntime.async(function _executeAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!props.redirectUrl) {\n            props.redirectUrl = getDefaultOAuthRedirect();\n          }\n\n          assertValidProps(props);\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(ExpoAppAuth.executeAsync(props));\n\n        case 4:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  });\n}\n\nexport function getDefaultOAuthRedirect() {\n  return ExpoAppAuth.OAuthRedirect + \":/oauthredirect\";\n}\nexport function authAsync(props) {\n  return _regeneratorRuntime.async(function authAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (ExpoAppAuth.executeAsync) {\n            _context2.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-app-auth', 'authAsync');\n\n        case 2:\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(_executeAsync(props));\n\n        case 4:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  });\n}\nexport function refreshAsync(props, refreshToken) {\n  return _regeneratorRuntime.async(function refreshAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (ExpoAppAuth.executeAsync) {\n            _context3.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-app-auth', 'refreshAsync');\n\n        case 2:\n          if (refreshToken) {\n            _context3.next = 4;\n            break;\n          }\n\n          throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot refresh with null `refreshToken`');\n\n        case 4:\n          _context3.next = 6;\n          return _regeneratorRuntime.awrap(_executeAsync(_objectSpread({\n            isRefresh: true,\n            refreshToken: refreshToken\n          }, props)));\n\n        case 6:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 7:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  });\n}\nexport function revokeAsync(_ref2, _ref3) {\n  var clientId, issuer, serviceConfiguration, token, _ref3$isClientIdProvi, isClientIdProvided, revocationEndpoint, response, openidConfig, encodedClientID, encodedToken, body, headers, results;\n\n  return _regeneratorRuntime.async(function revokeAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          clientId = _ref2.clientId, issuer = _ref2.issuer, serviceConfiguration = _ref2.serviceConfiguration;\n          token = _ref3.token, _ref3$isClientIdProvi = _ref3.isClientIdProvided, isClientIdProvided = _ref3$isClientIdProvi === void 0 ? false : _ref3$isClientIdProvi;\n\n          if (token) {\n            _context4.next = 4;\n            break;\n          }\n\n          throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot revoke a null `token`');\n\n        case 4:\n          assertValidClientId(clientId);\n\n          if (!(serviceConfiguration && serviceConfiguration.revocationEndpoint)) {\n            _context4.next = 9;\n            break;\n          }\n\n          revocationEndpoint = serviceConfiguration.revocationEndpoint;\n          _context4.next = 17;\n          break;\n\n        case 9:\n          _context4.next = 11;\n          return _regeneratorRuntime.awrap(fetch(issuer + \"/.well-known/openid-configuration\"));\n\n        case 11:\n          response = _context4.sent;\n          _context4.next = 14;\n          return _regeneratorRuntime.awrap(response.json());\n\n        case 14:\n          openidConfig = _context4.sent;\n          invariant(openidConfig.revocation_endpoint, 'The OpenID config does not specify a revocation endpoint');\n          revocationEndpoint = openidConfig.revocation_endpoint;\n\n        case 17:\n          encodedClientID = encodeURIComponent(clientId);\n          encodedToken = encodeURIComponent(token);\n          body = \"token=\" + encodedToken + (isClientIdProvided ? \"&client_id=\" + encodedClientID : '');\n          headers = {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          };\n          _context4.prev = 21;\n          _context4.next = 24;\n          return _regeneratorRuntime.awrap(fetch(revocationEndpoint, {\n            method: 'POST',\n            headers: headers,\n            body: body\n          }));\n\n        case 24:\n          results = _context4.sent;\n          return _context4.abrupt(\"return\", results);\n\n        case 28:\n          _context4.prev = 28;\n          _context4.t0 = _context4[\"catch\"](21);\n          throw new CodedError('ERR_APP_AUTH_REVOKE_FAILED', _context4.t0.message);\n\n        case 31:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[21, 28]]);\n}\n\nfunction parseAuthRevocationResults(results) {\n  var data, token, retryAfterValue, retryAfter;\n  return _regeneratorRuntime.async(function parseAuthRevocationResults$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return _regeneratorRuntime.awrap(results.json());\n\n        case 2:\n          data = _context5.sent;\n          token = results.headers['update-client-auth'];\n\n          if (!results.ok) {\n            _context5.next = 8;\n            break;\n          }\n\n          return _context5.abrupt(\"return\", {\n            type: 'success',\n            status: results.status,\n            data: data,\n            token: token\n          });\n\n        case 8:\n          if (!(results.status === 503 && results.headers['retry-after'])) {\n            _context5.next = 14;\n            break;\n          }\n\n          retryAfterValue = results.headers['retry-after'];\n\n          if (retryAfterValue) {\n            retryAfter = parseRetryTime(retryAfterValue);\n          }\n\n          return _context5.abrupt(\"return\", {\n            type: 'failed',\n            status: results.status,\n            data: data,\n            token: token,\n            retryAfter: retryAfter\n          });\n\n        case 14:\n          return _context5.abrupt(\"return\", {\n            type: 'error',\n            status: results.status,\n            data: data,\n            token: token\n          });\n\n        case 15:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  });\n}\n\nfunction parseRetryTime(value) {\n  if (/^\\d+$/.test(value)) {\n    return parseInt(value, 10) * 1000;\n  }\n\n  var retry = Date.parse(value);\n\n  if (isNaN(retry)) {\n    throw new CodedError('ERR_APP_AUTH_FETCH_RETRY_TIME', 'Cannot parse the Retry-After header value returned by the server: ' + value);\n  }\n\n  var now = Date.now();\n  var parsedDate = new Date(retry);\n  return parsedDate.getTime() - now;\n}\n\nvar OAuthRedirect = ExpoAppAuth.OAuthRedirect,\n    URLSchemes = ExpoAppAuth.URLSchemes;\nexport { OAuthRedirect, URLSchemes };","map":{"version":3,"sources":["../src/AppAuth.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, UnavailabilityError } from '@unimodules/core';\nimport invariant from 'invariant';\n\nimport {\n  OAuthBaseProps,\n  OAuthProps,\n  OAuthRevokeOptions,\n  OAuthServiceConfiguration,\n  TokenResponse,\n} from './AppAuth.types';\nimport ExpoAppAuth from './ExpoAppAuth';\n\nexport * from './AppAuth.types';\n\nfunction isValidServiceConfiguration(config?: OAuthServiceConfiguration): boolean {\n  return !!(\n    config &&\n    typeof config.authorizationEndpoint === 'string' &&\n    typeof config.tokenEndpoint === 'string'\n  );\n}\n\nfunction assertValidClientId(clientId?: string): void {\n  if (typeof clientId !== 'string' || !clientId.length) {\n    throw new CodedError(\n      'ERR_APP_AUTH_INVALID_CONFIG',\n      '`clientId` must be a string with more than 0 characters'\n    );\n  }\n}\n\nfunction assertValidProps({\n  issuer,\n  redirectUrl,\n  clientId,\n  serviceConfiguration,\n}: OAuthProps): void {\n  if (typeof issuer !== 'string' && !isValidServiceConfiguration(serviceConfiguration)) {\n    throw new CodedError(\n      'ERR_APP_AUTH_INVALID_CONFIG',\n      'You must provide either an `issuer` or both `authorizationEndpoint` and `tokenEndpoint`'\n    );\n  }\n  if (typeof redirectUrl !== 'string') {\n    throw new CodedError('ERR_APP_AUTH_INVALID_CONFIG', '`redirectUrl` must be a string');\n  }\n  assertValidClientId(clientId);\n}\n\nasync function _executeAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!props.redirectUrl) {\n    props.redirectUrl = getDefaultOAuthRedirect();\n  }\n  assertValidProps(props);\n  return await ExpoAppAuth.executeAsync(props);\n}\n\nexport function getDefaultOAuthRedirect(): string {\n  return `${ExpoAppAuth.OAuthRedirect}:/oauthredirect`;\n}\n\nexport async function authAsync(props: OAuthProps): Promise<TokenResponse> {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'authAsync');\n  }\n  return await _executeAsync(props);\n}\n\nexport async function refreshAsync(\n  props: OAuthProps,\n  refreshToken: string\n): Promise<TokenResponse> {\n  if (!ExpoAppAuth.executeAsync) {\n    throw new UnavailabilityError('expo-app-auth', 'refreshAsync');\n  }\n  if (!refreshToken) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot refresh with null `refreshToken`');\n  }\n  return await _executeAsync({\n    isRefresh: true,\n    refreshToken,\n    ...props,\n  });\n}\n\n/* JS Method */\nexport async function revokeAsync(\n  { clientId, issuer, serviceConfiguration }: OAuthBaseProps,\n  { token, isClientIdProvided = false }: OAuthRevokeOptions\n): Promise<any> {\n  if (!token) {\n    throw new CodedError('ERR_APP_AUTH_TOKEN', 'Cannot revoke a null `token`');\n  }\n\n  assertValidClientId(clientId);\n\n  let revocationEndpoint;\n  if (serviceConfiguration && serviceConfiguration.revocationEndpoint) {\n    revocationEndpoint = serviceConfiguration.revocationEndpoint;\n  } else {\n    // For Open IDC providers only.\n    const response = await fetch(`${issuer}/.well-known/openid-configuration`);\n    const openidConfig = await response.json();\n\n    invariant(\n      openidConfig.revocation_endpoint,\n      'The OpenID config does not specify a revocation endpoint'\n    );\n\n    revocationEndpoint = openidConfig.revocation_endpoint;\n  }\n\n  const encodedClientID = encodeURIComponent(clientId);\n  const encodedToken = encodeURIComponent(token);\n  const body = `token=${encodedToken}${isClientIdProvided ? `&client_id=${encodedClientID}` : ''}`;\n  const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n  try {\n    // https://tools.ietf.org/html/rfc7009#section-2.2\n    const results = await fetch(revocationEndpoint, {\n      method: 'POST',\n      headers,\n      body,\n    });\n\n    return results;\n  } catch (error) {\n    throw new CodedError('ERR_APP_AUTH_REVOKE_FAILED', error.message);\n  }\n}\n\n// NOTE: This function is unused; delete it if we don't need it\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nasync function parseAuthRevocationResults(results: Response): Promise<any> {\n  const data = await results.json();\n  const token = results.headers['update-client-auth'];\n  // the token has been revoked successfully or the client submitted an invalid token.\n  if (results.ok) {\n    // successful op\n    return { type: 'success', status: results.status, data, token };\n  } else if (results.status === 503 && results.headers['retry-after']) {\n    // Failed op\n    const retryAfterValue = results.headers['retry-after'];\n    let retryAfter: number | undefined;\n    if (retryAfterValue) {\n      retryAfter = parseRetryTime(retryAfterValue);\n    }\n    // the client must assume the token still exists and may retry after a reasonable delay.\n    return { type: 'failed', status: results.status, data, token, retryAfter };\n  } else {\n    // Error\n    return { type: 'error', status: results.status, data, token };\n  }\n}\n\nfunction parseRetryTime(value: string): number {\n  // In accordance with RFC2616, Section 14.37. Timout may be of format seconds or future date time value\n  if (/^\\d+$/.test(value)) {\n    return parseInt(value, 10) * 1000;\n  }\n  const retry = Date.parse(value);\n  if (isNaN(retry)) {\n    throw new CodedError(\n      'ERR_APP_AUTH_FETCH_RETRY_TIME',\n      'Cannot parse the Retry-After header value returned by the server: ' + value\n    );\n  }\n  const now = Date.now();\n  const parsedDate = new Date(retry);\n  return parsedDate.getTime() - now;\n}\n\nexport const { OAuthRedirect, URLSchemes } = ExpoAppAuth;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}